import axios, { AxiosError, AxiosResponse, InternalAxiosRequestConfig } from '@ohos/axios';
import { App, AppEnv, HttpDomain, LogDomain } from '../App';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { Authorization } from '../models/Auth';
import { PersistenceV2 } from '@kit.ArkUI';
import { application } from '@kit.AbilityKit';

const authorization =
  (): Authorization => PersistenceV2.globalConnect({ type: Authorization, defaultCreator: () => new Authorization() })!

const url = (): string => {
  const env = App.env;

  if (AppEnv.TEST === env) {
    return HttpDomain.TEST;
  }

  return HttpDomain.PROD
}

const http = axios.create();

http.defaults.baseURL = url();
http.defaults.timeout = 5000;
http.defaults.headers.common['Author'] = 'yansongda <me@yansongda.cn>';
http.defaults.headers.common['User-Agent'] = 'yansongda/atomicservice/MFA-v' + App.version + '-' + App.env;
http.defaults.headers.post['Content-Type'] = 'application/json';

http.interceptors.request.use((config: InternalAxiosRequestConfig) => {
  config.headers['Authorization'] = authorization().accessToken;

  hilog.info(LogDomain.UTILS, 'utils/http',
    '发送 http 请求，url: %{public}s, method: %{public}s, headers: %{public}s, request body: %{public}s', config.url,
    config.method,
    JSON.stringify(config.headers), JSON.stringify(config.data));

  return config;
}, (e: AxiosError) => {
  hilog.error(LogDomain.UTILS, 'utils/http',
    '发送 http 请求失败，message: %{public}s, url: %{public}s, method: %{public}s, headers: %{public}s, request body: %{public}s',
    e.message,
    e.config?.url, e.config?.method, JSON.stringify(e.config?.headers), JSON.stringify(e.config?.data));

  let message = '网络错误，请检查网络状态';

  try {
    message =
      application.getApplicationContext().resourceManager.getStringSync($r('app.string.error_http_request_failed').id)
  } catch (e) {
  }

  return Promise.reject(new HttpError(message));
});

// todo：token 过期自动续签处理
http.interceptors.response.use((response: AxiosResponse): AxiosResponse => {
  hilog.info(LogDomain.UTILS, 'utils/http',
    '接收 http 请求响应，url: %{public}s, method: %{public}s, response body: %{public}s, time: %{public}s',
    response.config.url,
    response.config.method, JSON.stringify(response.data), JSON.stringify(response.performanceTiming));

  return response;
}, (e: AxiosError) => {
  hilog.error(LogDomain.UTILS, 'utils/http',
    '接收 http 请求失败，code: %{public}s, message: %{public}s, url: %{public}s, method: %{public}s, request body: %{public}s, response body: %{public}s',
    e.code, e.message, e.config?.url, e.config?.method, JSON.stringify(e.config?.data), JSON.stringify(e.response?.data)
  );

  let message = '服务器响应错误，请重试或联系我们';

  try {
    message =
      application.getApplicationContext().resourceManager.getStringSync($r('app.string.error_http_response_failed').id)
  } catch (e) {
  }

  return Promise.reject(new HttpError(message));
});

export interface Response<T> {
  code: number,
  message: string,
  data?: T,
}

export class HttpError extends Error {
}

export default http;